<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
    <entry key="node_file" type="xstring" value="settings.xml"/>
    <config key="flow_stack"/>
    <config key="internal_node_subsettings">
        <entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
    </config>
    <config key="model">
        <entry key="sourceCode" type="xstring" value="# Predicting Demand%%00010# Created by Ashley Bedford%%00010%%00010# This project will use actual demand across the past 10 weeks (Weeks -14 through -5) to predict the demand%%00010# of the past 4 weeks (Weeks -4 through -1) of demand for all of our products. In total a 14-week window is used, which%%00010# equates to a trailing Quarter. The XGBoost Model will keep track of historical data over time to improve prediction%%00010# results. We will use this on AA, A, and B items with at least 14 weeks of sales data available.%%00010%%00010import math%%00010%%00010import matplotlib.pyplot as plt%%00010import os.path%%00010import pickle%%00010import numpy as np%%00010import pandas as pd%%00010import sklearn%%00010from sklearn.model_selection import train_test_split%%00010from sklearn.linear_model import LinearRegression%%00010from sklearn.metrics import mean_squared_error%%00010%%00010from numpy import asarray%%00010from pandas import concat%%00010from pandas import DataFrame%%00010from sklearn.metrics import mean_absolute_error%%00010from xgboost import XGBRegressor%%00010%%00010%%00010# transform a time series dataset into a supervised learning dataset%%00010def series_to_supervised(data, n_in=1, n_out=1, dropnan=True):%%00010    n_vars = 1 # if type(data) is list else data.shape[1]%%00010    df = DataFrame(data)%%00010    cols = list()%%00010    # input sequence (t-n, ... t-1)%%00010    for i in range(n_in, 0, -1):%%00010        cols.append(df.shift(i))%%00010    # forecast sequence (t, t+1, ... t+n)%%00010    for i in range(0, n_out):%%00010        cols.append(df.shift(-i))%%00010    # put it all together%%00010    agg = concat(cols, axis=1)%%00010    # drop rows with NaN values%%00010    if dropnan:%%00010        agg = agg.iloc[:, -3:]%%00010        agg.dropna(inplace=True)%%00010        agg = agg.iloc[:, [True, False, True]]%%00010    return agg.values%%00010%%00010%%00010# walk-forward validation for univariate data%%00010def walk_forward_validation(data, n_test, group_name):%%00010    predictions = list()%%00010    # split dataset%%00010    train, test = train_test_split(data, n_test)%%00010    # seed history with training dataset%%00010    history = [x for x in train]%%00010    # step over each time-step in the test set%%00010    for i in range(len(test)):%%00010        # split test row into input and output columns%%00010        testX, testy = test[i, :-1], test[i, -1]%%00010        # fit model on history and make a prediction%%00010        yhat, model = xgboost_forecast(history, testX, group_name)%%00010        # store forecast in list of predictions%%00010        predictions.append(yhat)%%00010        # add actual observation to history for the next loop%%00010        history.append(test[i])%%00010        # summarize progress%%00010        # print('&gt;expected=%.1f, predicted=%.1f' % (testy, yhat))%%00010    # estimate prediction error%%00010    error = mean_absolute_error(test[:, -1], predictions)%%00010    return error, test[:, 1], predictions, model%%00010%%00010%%00010# split a uni-variate dataset into train/test sets%%00010def train_test_split(data, n_test):%%00010    return data[:-n_test, :], data[-n_test:, :]%%00010%%00010%%00010# fit the xgboost model and make a one-step prediction%%00010def xgboost_forecast(train, testX, group_name):%%00010    # transform list into array%%00010    train = asarray(train)%%00010    # split into input and output columns%%00010    trainX, trainy = train[:, :-1], train[:, -1]%%00010%%00010    path = flow_variables['knime.workspace'] + os.sep + group_name%%00010%%00010    if os.path.exists(path):%%00010        # pull the saved model and fit it%%00010        model = pickle.load(open(path, 'rb'))%%00010        model.fit(trainX, trainy)%%00010%%00010    else:%%00010        # fit model%%00010        model = XGBRegressor(objective='reg:squarederror', n_estimators=1000)%%00010        model.fit(trainX, trainy)        %%00010%%00010        pickle.dump(model, open(path, 'wb'))%%00010%%00010    # make a one-step prediction%%00010    yhat1 = model.predict([testX])%%00010    return yhat1[0], model%%00010%%00010%%00010# load the dataset%%00010%%00010# Import Sales Data%%00010df = pd.DataFrame(input_table_1.copy())%%00010%%00010df['-1'] = df['-1'].fillna(0)%%00010df['-2'] = df['-2'].fillna(0)%%00010df['-3'] = df['-3'].fillna(0)%%00010df['-4'] = df['-4'].fillna(0)%%00010df['-5'] = df['-5'].fillna(0)%%00010df['-6'] = df['-6'].fillna(0)%%00010df['-7'] = df['-7'].fillna(0)%%00010df['-8'] = df['-8'].fillna(0)%%00010df['-9'] = df['-9'].fillna(0)%%00010df['-10'] = df['-10'].fillna(0)%%00010df['-11'] = df['-11'].fillna(0)%%00010df['-12'] = df['-12'].fillna(0)%%00010df['-13'] = df['-13'].fillna(0)%%00010df['-14'] = df['-14'].fillna(0)%%00010%%00010grouped = df.groupby(['Grouping'])%%00010%%00010m = 1%%00010output_model_list = []%%00010mae_list = []%%00010%%00010print(len(list(grouped)))%%00010%%00010for group in list(grouped):%%00010    group_df = pd.DataFrame(group)%%00010    group_df_vals = group_df.values%%00010    print(group_df_vals)%%00010%%00010    group_name = ''%%00010%%00010    for x in group_df_vals:%%00010        if x == group_df_vals[0]:%%00010            new_file_name = x[0].replace('/', '_')%%00010            group_name = new_file_name + '.pkl'%%00010            continue%%00010%%00010        for y in x:%%00010%%00010            item_vals = y.values%%00010%%00010            for z in item_vals:%%00010%%00010                name = z[0]%%00010                %%00010                new = [[-14, z[6]], [-13, z[7]], [-12, z[8]], [-11, z[9]], [-10, z[10]], [-9, z[11]], [-8, z[12]],%%00010                       [-7, z[13]], [-6, z[14]], [-5, z[15]], [-4, z[16]], [-3, z[17]], [-2, z[18]], [-1, z[19]]]%%00010%%00010                test_df = pd.DataFrame(new, columns=['time', 'measure'])%%00010%%00010                test_values = test_df.values%%00010%%00010                # transform the time series data into supervised learning%%00010                data = series_to_supervised(test_values, n_in=14)%%00010%%00010                mae, y, yhat2, model = walk_forward_validation(data, 4, group_name)%%00010%%00010                # print('MAE: %.3f' % mae)                %%00010                exec(&quot;output_model_&quot;+ str(m) + &quot; = model&quot;)%%00010                output_model_list.append(&quot;output_model_&quot;+ str(m))%%00010                mae_list.append(mae)%%00010%%00010                m = m + 1%%00010%%00010df2 = df.assign(output_model = output_model_list)%%00010output_table_1 = df2.assign(mae = mae_list)%%00010%%00010                # # plot expected vs predicted%%00010                # plt.plot(y, label='Expected')%%00010                # plt.plot(yhat2, label='Predicted')%%00010                # plt.legend()%%00010                # plt.savefig(str(name) + '.png')%%00010%%00010"/>
        <entry key="rowLimit" type="xint" value="1000"/>
        <entry key="convertMissingToPython" type="xboolean" value="false"/>
        <entry key="convertMissingFromPython" type="xboolean" value="false"/>
        <entry key="sentinelOption" type="xstring" value="MIN_VAL"/>
        <entry key="sentinelValue" type="xint" value="0"/>
        <entry key="chunkSize" type="xint" value="500000"/>
        <entry key="pythonVersionOption" type="xstring" value="python3"/>
        <entry key="python2Command" type="xstring" value=""/>
        <entry key="python3Command" type="xstring" value=""/>
    </config>
    <config key="nodeAnnotation">
        <entry key="text" type="xstring" value="CREATE the XGBoost %%00013%%00010Forecast on the %%00013%%00010Table of Products"/>
        <entry key="bgcolor" type="xint" value="16777215"/>
        <entry key="x-coordinate" type="xint" value="2821"/>
        <entry key="y-coordinate" type="xint" value="1020"/>
        <entry key="width" type="xint" value="118"/>
        <entry key="height" type="xint" value="45"/>
        <entry key="alignment" type="xstring" value="CENTER"/>
        <entry key="borderSize" type="xint" value="0"/>
        <entry key="borderColor" type="xint" value="16777215"/>
        <entry key="defFontSize" type="xint" value="9"/>
        <entry key="annotation-version" type="xint" value="20151123"/>
        <config key="styles">
            <config key="style_0">
                <entry key="start" type="xint" value="0"/>
                <entry key="length" type="xint" value="6"/>
                <entry key="fontname" type="xstring" value="Arial"/>
                <entry key="fontstyle" type="xint" value="1"/>
                <entry key="fontsize" type="xint" value="9"/>
                <entry key="fgcolor" type="xint" value="10747904"/>
            </config>
        </config>
    </config>
    <entry key="customDescription" type="xstring" isnull="true" value=""/>
    <entry key="state" type="xstring" value="IDLE"/>
    <entry key="factory" type="xstring" value="org.knime.python2.nodes.script2.Python2ScriptNodeFactory2"/>
    <entry key="node-name" type="xstring" value="Python Script"/>
    <entry key="node-bundle-name" type="xstring" value="KNIME Python nodes"/>
    <entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.python2.nodes"/>
    <entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
    <entry key="node-bundle-version" type="xstring" value="4.4.0.v202106250919"/>
    <entry key="node-feature-name" type="xstring" value="KNIME Python Integration"/>
    <entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.python2.feature.group"/>
    <entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
    <entry key="node-feature-version" type="xstring" value="4.4.0.v202106250919"/>
    <config key="factory_settings"/>
    <config key="node_creation_config">
        <config key="Input object (pickled)"/>
        <config key="Input table">
            <config key="port_0">
                <entry key="object_class" type="xstring" value="org.knime.core.node.BufferedDataTable"/>
            </config>
        </config>
        <config key="Output table">
            <config key="port_0">
                <entry key="object_class" type="xstring" value="org.knime.core.node.BufferedDataTable"/>
            </config>
        </config>
        <config key="Output image"/>
        <config key="Output object (pickled)"/>
    </config>
    <entry key="name" type="xstring" value="Python Script"/>
    <entry key="hasContent" type="xboolean" value="false"/>
    <entry key="isInactive" type="xboolean" value="false"/>
    <config key="ports">
        <config key="port_1">
            <entry key="index" type="xint" value="1"/>
            <entry key="port_dir_location" type="xstring" isnull="true" value=""/>
        </config>
    </config>
    <config key="filestores">
        <entry key="file_store_location" type="xstring" isnull="true" value=""/>
        <entry key="file_store_id" type="xstring" isnull="true" value=""/>
    </config>
</config>
